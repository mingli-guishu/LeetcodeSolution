class Solution {
    // 115 Hard 不同的子序列 distinct-subsequences
    // dp非优化
    public int numDistinct(String s, String t) {
        int slen = s.length();
        int tlen = t.length();
        // dp表示s从i到尾，t从j到尾，是否能匹配
        int[][] dp = new int[slen + 1][tlen + 1]; // +1位置是在尾部看成空串
        // 当t为空串进行匹配时，空串属于任何串的子串
        for (int i = 0; i <= slen; i++)
            dp[i][tlen] = 1;
        // 当s为空串但t不为空串时，t不属于子串
        // for (int j = 0; j < tlen; j++)
        //     dp[slen][j] = 0;
        for (int i = slen - 1; i >= 0; i--) {
            char cur_s = s.charAt(i);
            for (int j = tlen - 1; j >= 0; j--) {
                if (cur_s == t.charAt(j))
                    // 若相同，判断是否要用掉（抵消掉）当前的字符
                    // 如此时s到尾部：bgbag，t到尾部：bag，此时i和j都指向各自的最前的位置，均为b
                    // 若用掉：考虑gbag和ag
                    // 若不用掉，考虑gbag和bag，也就是不用掉的话在后序的匹配中可以使用
                    // 当前 = 用掉 + 不用掉
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
                else
                    // 不同，则用不了（抵消不了）
                    dp[i][j] = dp[i + 1][j];
            }
        }
        return dp[0][0];
    }
    
    // dp优化
    public int numDistinct(String s, String t) {
        int slen = s.length();
        int tlen = t.length();
        int[] dp = new int[tlen + 1]; // +1位置是在尾部看成空串
        dp[tlen] = 1;
        for (int i = slen - 1; i >= 0; i--) {
            char cur_s = s.charAt(i);
            // 为了防止覆盖，从前往后遍历
            for (int j = 0; j < tlen; j++) 
                if (cur_s == t.charAt(j))
                    dp[j] += dp[j + 1];
        }
        return dp[0];
    }
}

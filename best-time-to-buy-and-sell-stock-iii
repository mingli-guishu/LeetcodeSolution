class Solution {
    // 123 Hard 买卖股票的最佳时机Ⅲ best-time-to-buy-and-sell-stock-iii
    // 课上的思路
    public int maxProfit(int[] prices) {
        int[][][] dp = new int[prices.length][2][3];// 3 = 2 + 1

        // 边界
        for (int k = 0; k <= 2; k++) {
            dp[0][0][k] = 0;
            dp[0][1][k] = -prices[0];
        }
        
        for (int i = 1; i < prices.length; i++) {
            for (int k = 0; k <= 2; k++) {
                // 未持有：前一天未持有 或 今天卖出，完成了一次交易
                if (k > 0)
                    dp[i][0][k] = Math.max(dp[i - 1][0][k], dp[i - 1][1][k - 1] + prices[i]);
                else
                    dp[i][0][k] = dp[i - 1][0][k];
                // 持有，前一天持有 或 今天买入
                dp[i][1][k] = Math.max(dp[i - 1][1][k], dp[i - 1][0][k] - prices[i]);
            }
        }

        // find ans
        int ans = 0;
        for (int k = 0; k <= 2; k++)
            ans = Math.max(ans, dp[prices.length - 1][0][k]);
        return ans;
    }
    
    // 优化后
    public int maxProfit(int[] prices) {
        int buy1 = -prices[0], buy2 = -prices[0];
        int sell1 = 0, sell2 = 0;
        for (int i = 0; i < prices.length; i++) {
            // buy1 第一次买入，上一天已经买了 或 （在0之上）今天买入
            buy1 = Math.max(buy1, -prices[i]);
            // sell1 第一次卖出，上一天已经卖了 或 （buy1之上）今天卖了
            sell1 = Math.max(sell1, buy1 + prices[i]);
            // buy2 第二次买入，上一天已经买了 或 （在sell1之上）今天买了
            buy2 = Math.max(buy2, sell1 - prices[i]);
            // sell2 第二次卖出，上一天已经卖了 或 （在buy2之上）今天卖了
            sell2 = Math.max(sell2, buy2 + prices[i]);

            // 这四个运算存在顺序，但同一天的买入和卖出相当于于不作为
        }
        return  sell2;
    }
}

class Solution {
    // 10 Hard 正则表达式 regular-expression-matching
    public boolean isMatch(String s, String p) {
        // dp
        int slen = s.length();
        int plen = p.length();
        // 前i个位置能否匹配前j个位置
        boolean[][] dp = new boolean[slen + 1][plen + 1]; // +1是判断p能否匹配空串
        dp[0][0] = true;
        // i = 0,p是否能匹配空串
        for (int j = 1; j < plen; j++) // j = 0 一定不能匹配空串
            if (p.charAt(j) == '*')
                dp[0][j + 1] = dp[0][j - 1];
        for (int i = 0; i < slen; i++) {
            char cur_s = s.charAt(i);
            for (int j = 0; j < plen; j++) {
                char cur_p = p.charAt(j);
                if (cur_p != '*') { // 非*时，只要前面的匹配了，当前位置匹配了就为true
                    dp[i + 1][j + 1] = dp[i][j] && (cur_s == cur_p || cur_p == '.');
                } else { // *当成前面字符使用零次 || 当成使用一次 || 当成使用多次
                    dp[i + 1][j + 1] = dp[i + 1][j - 1] || dp[i + 1][j] || 
                        (dp[i][j + 1] && (cur_s == p.charAt(j - 1) || p.charAt(j - 1) == '.'));
                }
            } 
        }
        return dp[slen][plen];
    }
}

class Solution {
    // 130 Medium 被围绕的区域 surrounded-regions
    boolean[][] visited;
    char[][] board;
    int rows, cols;
    public void solve(char[][] board) {
        this.rows = board.length;
        this.cols = board[0].length;
        this.board = board;
        visited = new boolean[rows][cols];
        // 从边上搜索出不能变成X的O
        for (int i = 0; i < rows; i++) {
            if (board[i][0] == 'O' && !visited[i][0])
                dfs(i, 0);
            if (board[i][cols - 1] == 'O' && !visited[i][cols - 1])
                dfs(i, cols - 1);
        }
        for (int i = 0; i < cols; i++) {
            if (board[0][i] == 'O' && !visited[0][i])
                dfs(0, i);
            if (board[rows - 1][i] == 'O' && !visited[rows - 1][i])
                dfs(rows - 1, i);
        }
        // 找到中间的要变成X的O
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++)
                if (board[i][j] == 'O' && !visited[i][j])
                    board[i][j] = 'X';
    }

    private void dfs(int x, int y) {
        // 保证合法并且没有访问过
        if (x == -1 || x == rows || y == -1 || y == cols || board[x][y] == 'X' || visited[x][y])
            return;
        visited[x][y] = true;
        dfs(x - 1, y);
        dfs(x + 1, y);
        dfs(x, y - 1);
        dfs(x, y + 1);
    }
}

class Solution {
    // 239 Hard 滑动窗口的最大值 sliding-window-maximum
    // 整体思路：
    // 由于记录的是滑动窗口的最大值，那么维护一个递减队列，队列的头就是该队列的最大值，那么当记录最大值时peek队头即可，当队头滑出窗体后，由于是递减队列，新队头就是最大值
    // 1、队头合法性：滑动窗体会整体向右移动，所以要注意队头是否滑出窗体了，所以每次循环第一步便是check队头是否滑出
    // 2、维护单调性：将当前循环到的值从队尾开始比较，直到达到合适位置入队或为队列为空
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 单调队列
        int[] ans = new int[nums.length - k + 1];
        // 队列存下标，下标是递增的，对应的值是递减的
        // 对头是下标最小的一侧，也是队列中最大的数
        Deque<Integer> queue = new ArrayDeque<Integer>();
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            // 队头合法性
            if (!queue.isEmpty() && queue.peekFirst() <= i - k)
                queue.pollFirst();
            // 维护单调性
            while (!queue.isEmpty() && nums[queue.peekLast()] <= nums[i])
                queue.pollLast();
            queue.offerLast(i);
            // 当i移动到一定位置时（这个位置取决于k的大小），才可以放入ans
            if (i >= k - 1)
                ans[index++] = nums[queue.peekFirst()];
        }
        return ans;
    }
}

class Solution {
    // 106 Medium 从中序与后序遍历序列构造二叉树 construct-binary-tree-from-inorder-and-postorder-traversal
    // 递归解法
    int[] inorder;
    int[] postorder;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        // 方法同105前序+中序
        this.inorder = inorder;
        this.postorder = postorder;
        return create(0, inorder.length - 1, 0, postorder.length - 1);
    }

    // [9 | 3 | 15,20,7] in
    // [9 | 15,7,20 | 3] post
    private TreeNode create(int l1, int r1, int l2, int r2) {
        // 终止条件
        if (l1 > r1) {
            return null;
        }
        // 后序root在最后的位置
        // 找到中序中root位置
        int rootindex = l1;
        while (inorder[rootindex] != postorder[r2])
            rootindex++;
        TreeNode node = new TreeNode(postorder[r2]);
        // 左子树长度: rootindex - l1
        // 右子树长度: r1 - rootindex
        node.left = create(l1, rootindex - 1, l2, l2 + rootindex - l1 - 1);
        node.right = create(rootindex + 1, r1, l2 + rootindex - l1, r2 - 1);
        return node;
    }

    // dfs解法
}

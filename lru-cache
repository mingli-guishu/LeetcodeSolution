class LRUCache {
    // 146 Medium LRU缓存机制 lru-cache
    // O(1)查找：map.get()
    // O(1)更新：map定位，删除节点，头部新增节点
    // O(1)删除：淘汰尾结点，map中删除
    int cap;
    int size = 0;
    HashMap<Integer, Node> map;
    Node head;
    Node tail;
    public LRUCache(int capacity) {
        this.cap = capacity;
        map = new HashMap<Integer, Node>();
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.pre = head;
    }
    
    public int get(int key) {
        Node node = map.getOrDefault(key, null);
        // map中不存在该节点
        if (node == null)
            return -1;
        // map存在该节点
        // 更新位置，size不变
        delete(node);
        map.put(key, addTohead(key, node.value));
        return node.value;
    }
    
    public void put(int key, int value) {
        Node node = map.getOrDefault(key, null);
        // map中存在该节点
        if (node != null) {
            // 更新位置，size不变
            delete(node);
            map.put(key, addTohead(key, value));
        } else { // map中不存在该节点
            if (size == cap) {
                // 删除最后一个节点
                map.remove(tail.pre.key);
                tail.pre = tail.pre.pre;
                tail.pre.next = tail;
                size--;
            }
            map.put(key, addTohead(key, value));
            size++;
        }
    }

    // 增加到头
    private Node addTohead(int key, int value) {
        Node node = new Node(key, value);
        // 四个指针需要更新
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
        return node;
    }

    private void delete(Node node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }

    // key的用处：从map中删除最后一个节点时用到map.remove(tail.pre.key)
    // 为什么是双向链表而不能是单向？即pre的用处？
    // pre的用处：在删除某个节点时要使node.pre.next = node.next，删除最后一个节点时也要用到tail.pre
    private class Node {
        int key;
        int value;
        Node pre;
        Node next;
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}

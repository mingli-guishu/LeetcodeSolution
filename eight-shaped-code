import java.util.*;
import java.io.*;

class Main {
    // Acwing835 八字码
    // bfs
    PriorityQueue<int[]> q;
    HashMap<Integer, Integer> map;
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String[] input = in.readLine().split(" ");
        Main solve = new Main();
        System.out.println(solve.bfs(solve.trans(input)));
    }
    
    // 把String数组转换成int数组
    private int trans(String[] input) {
        int res = 0;
        for (int i = 0; i < 9; i++) {
            if (!input[i].equals("x"))
                res = res * 10 + Integer.valueOf(input[i]);
            else
                res = res * 10;
        }
        return res;
    }
    
    private int bfs(int start) {
        final int end = 123456780;
        q = new PriorityQueue<>(new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        map = new HashMap<>(); // 步数和状态
        q.offer(new int[]{calVal(unzip(start)), start});
        map.put(start, 0);
        while (!q.isEmpty()) {
            int state = q.poll()[1]; // 当前状态
            int step = map.get(state); // 当前步数
            int[] board = unzip(state);
            int zero = findZeroIndex(board);
            if (zero > 2) // 上
                addNextState(board, zero, zero - 3, step);
            if (zero < 6) // 下
                addNextState(board, zero, zero + 3, step);
            if (zero != 0 && zero != 3 && zero != 6) // 左
                addNextState(board, zero, zero - 1, step);
            if (zero != 2 && zero != 5 && zero != 8) // 右
                addNextState(board, zero, zero + 1, step);
            if (map.containsKey(end))
                return step + 1;
        }
        return -1;
    }
    
    private int calVal(int[] board) {
        int res = 0;
        for (int i = 0; i < 9; i++) {
            if (board[i] == 0) continue; 
            int x = i / 3, y = i % 3;
            int targetx = (board[i] - 1) / 3, targety = (board[i] - 1) % 3;
            res += Math.abs(targetx - x) + Math.abs(targety = y);
        }
        return res;
    }
    
    private void addNextState(int[] board, int zero, int targetIndex, int step) {
        swap(board, zero, targetIndex);
        int curState = zip(board);
        if (!map.containsKey(curState)) {
            q.offer(new int[]{step + 1 + calVal(board), curState});
            map.put(curState, step + 1);
        }
        swap(board, zero, targetIndex);
    }
    
    private void swap(int[] board, int a, int b) {
        int tmp = board[a];
        board[a] = board[b];
        board[b] = tmp;
    }
    
    // 从数组中找到0的位置
    private int findZeroIndex(int[] nums) {
        for (int i = 0; i < 9; i++)
            if (nums[i] == 0)
                return i;
        return -1;
    }
    
    // 数组变成数字信息
    private int zip(int[] nums) {
        int res = 0;
        for (int num : nums)
            res = res * 10 + num;
        return res;
    }
    
    // 把数字信息转换成数组
    private int[] unzip(int info) {
        int[] res = new int[9];
        for (int i = 8; i >= 0; i--) {
            res[i] = info % 10;
            info /= 10;
        }
        return res;
    }
    
    
    
    // ---------A*算法-----------
    PriorityQueue<int[]> q;
    HashMap<Integer, Integer> map;
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String[] input = in.readLine().split(" ");
        Main solve = new Main();
        System.out.println(solve.bfs(solve.trans(input)));
    }
    
    // 把String数组转换成int
    private int trans(String[] input) {
        int res = 0;
        for (int i = 0; i < 9; i++) {
            if (!input[i].equals("x"))
                res = res * 10 + Integer.valueOf(input[i]);
            else
                res = res * 10;
        }
        return res;
    }
    
    private int bfs(int start) {
        final int end = 123456780;
        q = new PriorityQueue<>(new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        map = new HashMap<>(); // 步数和状态
        q.offer(new int[]{calVal(unzip(start)), start});
        map.put(start, 0);
        while (!q.isEmpty()) {
            int state = q.poll()[1]; // 当前状态
            int step = map.get(state); // 当前步数
            int[] board = unzip(state);
            int zero = findZeroIndex(board);
            if (zero > 2) // 上
                addNextState(board, zero, zero - 3, step);
            if (zero < 6) // 下
                addNextState(board, zero, zero + 3, step);
            if (zero != 0 && zero != 3 && zero != 6) // 左
                addNextState(board, zero, zero - 1, step);
            if (zero != 2 && zero != 5 && zero != 8) // 右
                addNextState(board, zero, zero + 1, step);
            if (map.containsKey(end))
                return step + 1;
        }
        return -1;
    }
    
    private int calVal(int[] board) {
        int res = 0;
        for (int i = 0; i < 9; i++) {
            if (board[i] == 0) continue; 
            int x = i / 3, y = i % 3;
            int targetx = (board[i] - 1) / 3, targety = (board[i] - 1) % 3;
            res += Math.abs(targetx - x) + Math.abs(targety = y);
        }
        return res;
    }
    
    private void addNextState(int[] board, int zero, int targetIndex, int step) {
        swap(board, zero, targetIndex);
        int curState = zip(board);
        if (!map.containsKey(curState)) {
            q.offer(new int[]{step + 1 + calVal(board), curState});
            map.put(curState, step + 1);
        }
        swap(board, zero, targetIndex);
    }
    
    private void swap(int[] board, int a, int b) {
        int tmp = board[a];
        board[a] = board[b];
        board[b] = tmp;
    }
    
    // 从数组中找到0的位置
    private int findZeroIndex(int[] nums) {
        for (int i = 0; i < 9; i++)
            if (nums[i] == 0)
                return i;
        return -1;
    }
    
    // 数组变成数字信息
    private int zip(int[] nums) {
        int res = 0;
        for (int num : nums)
            res = res * 10 + num;
        return res;
    }
    
    // 把数字信息转换成数组
    private int[] unzip(int info) {
        int[] res = new int[9];
        for (int i = 8; i >= 0; i--) {
            res[i] = info % 10;
            info /= 10;
        }
        return res;
    }
}

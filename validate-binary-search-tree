class Solution {
    // 98 Medium 验证二叉搜索树 validate-binary-search-tree
    // 上课时的解法，存在一些冗余，本只需判断节点是否合法即可，却记录了多余条件
    public boolean isValidBST(TreeNode root) {
        return check(root).ifValid;
    }

    private Msg check(TreeNode root) {
        if (root == null)
            // 由于二叉搜索树必须满足：左子树最大<父节点，右子树最小>父节点，所以null时max返回一个很小的数，min返回一个很大的数来满足left_msg.max < root.val && root.val < right_msg.min
            return new Msg(Integer.MIN_VALUE - 1L, Integer.MAX_VALUE + 1L);
        Msg left_msg = check(root.left);
        Msg right_msg = check(root.right);
        Msg cur = new Msg(Math.max(root.val, Math.max(left_msg.max, right_msg.max)), Math.min(root.val, Math.min(left_msg.min, right_msg.min)));
        cur.ifValid = left_msg.ifValid && right_msg.ifValid && left_msg.max < root.val && root.val < right_msg.min;
        return cur;
    }

    // 利用一个类记录左右子树的信息
    private class Msg {
        boolean ifValid = true;// 子树是否合法
        long max;// 整个子树的最大值
        long min;// 整个子树的最小值
        public Msg (long max, long min) {
            this.max = max;
            this.min = min;
        }
    }
    
    // 官方解
    public boolean isValidBST(TreeNode root) {
        return check(root, Integer.MAX_VALUE + 1L, Integer.MIN_VALUE - 1L);
    }
    // 利用max和min来卡当前节点的范围
    private boolean check(TreeNode root, Long max, Long min) {
        // 终止条件
        if (root == null) 
            return true;
        // 当前节点不能大于最大值，也不能小于最小值
        if (root.val >= max || root.val <= min)
            return false;
        // 左子树的最大值不能大于父节点，右子树最小值不能小于父节点，改变max与min即可
        return check(root.left, (long)root.val, min) && check(root.right, max, (long)root.val);
    }
    
    // 还有一个中序遍历的解法也不错
}

class Solution {
    // 699 Hard 掉落的方块 falling-squares
    // 暴力模拟
    public List<Integer> fallingSquares(int[][] positions) {
        int len = positions.length;
        int[] height = new int[len]; // 每个方块的高度
        for (int i = 0; i < len; i++) {
            int left1 = positions[i][0];
            int size1 = positions[i][1];
            int right1 = left1 + size1;
            height[i] += size1;

            for (int j = i + 1; j < len; j++) {
                int left2 = positions[j][0];
                int size2 = positions[j][1];
                int right2 = left2 + size2;
                if (left2 < right1 && right2 > left1) // 叠上
                    height[j] = Math.max(height[j], height[i]);
            }
        }

        int max = -1;
        List<Integer> ans = new ArrayList<>(); 
        for (int num : height) {
            max = Math.max(max, num);
            ans.add(max);
        }
        return ans;
    }
    
    // ----------离散化 + 暴力模拟----------
    int[] height;
    public List<Integer> fallingSquares(int[][] positions) {
        // 离散化
        Set<Integer> all = new HashSet<Integer>();
        for (int[] po : positions) {
            all.add(po[0]);
            all.add(po[0] + po[1] - 1);
        }
        List<Integer> all_sorted = new ArrayList<>(all);
        Collections.sort(all_sorted);
        HashMap<Integer, Integer> map = new HashMap<>();
        int count = 0;
        for (int num : all_sorted)
            map.put(num, count++);
        
        // 暴力解
        height = new int[all_sorted.size()];
        List<Integer> ans = new ArrayList<>();
        int max = 0;
        for (int[] po : positions) {
            int l = map.get(po[0]);
            int r = map.get(po[0] + po[1] - 1);
            int h = query(l, r) + po[1]; // 当前这一次的高度
            update(l, r, h);
            max = Math.max(max, h);
            ans.add(max);
        }
        return ans;
    }

    private int query(int l, int r) {
        int res = 0;
        for (int i = l; i <= r; i++)
            res = Math.max(res, height[i]);
        return res;
    }

    private void update(int l, int r, int h) {
        for (int i = l; i <= r; i++)
            height[i] = Math.max(height[i], h);
    }
    
    // ----------离散化 + 线段树----------
    public List<Integer> fallingSquares(int[][] positions) {
        // 离散化
        Set<Integer> all = new HashSet<Integer>();
        for (int[] po : positions) {
            all.add(po[0]);
            all.add(po[0] + po[1] - 1);
        }
        List<Integer> all_sorted = new ArrayList<>(all);
        Collections.sort(all_sorted);
        HashMap<Integer, Integer> map = new HashMap<>();
        int count = 0;
        for (int num : all_sorted)
            map.put(num, count++);
        
        SegmentTree segtree = new SegmentTree(count);
        List<Integer> ans = new ArrayList<>();
        int max = 0;
        for (int[] po : positions) {
            int l = map.get(po[0]);
            int r = map.get(po[0] + po[1] - 1);
            int h = segtree.query(l, r) + po[1];
            segtree.update(l, r, h);
            max = Math.max(max, h);
            ans.add(max);
        }
        return ans;
    }
}

class SegmentTree {
    Node[] a;
    private class Node {
        int l, r;
        int mark; // 懒惰修改
        int data;
        Node(int l, int r) {
            this.l = l; 
            this.r = r;
            this.data = 0;
            this.mark = 0;
        }
    }

    SegmentTree(int len) {
        a = new Node[4 * len];
        build(1, 0, len - 1);
    }

    private void build(int cur, int l, int r) {
        a[cur] = new Node(l, r);
        if (l == r) return;
        int mid = l + (r - l) / 2;
        build(cur * 2, l, mid);
        build(cur * 2 + 1, mid + 1, r);
    }

    public int query(int l, int r) {
        return query(1, l, r);
    } 

    public void update(int l, int r, int h) {
        update(1, l, r, h);
    }

    // 区间查询
    private int query(int cur, int l, int r) {
        if (l <= a[cur].l && a[cur].r <= r)
            return a[cur].data;
        spread(cur);
        int res = 0;
        int mid = a[cur].l + (a[cur].r - a[cur].l) / 2;
        if (l <= mid) res = Math.max(res, query(cur * 2, l, r));
        if (r > mid)  res = Math.max(res, query(cur * 2 + 1, l, r));
        return res;
    }

    // 区间更新
    private void update(int cur, int l, int r, int h) {
        if (l <= a[cur].l && a[cur].r <= r) {
            a[cur].data = Math.max(a[cur].data, h);
            a[cur].mark = Math.max(h, a[cur].mark); // mark始终只对齐最高的
            return;
        }
        spread(cur);
        int mid = a[cur].l + (a[cur].r - a[cur].l) / 2;
        if (l <= mid) update(cur * 2, l, r, h);
        if (r > mid) update(cur * 2 + 1, l, r, h);
        a[cur].data = Math.max(a[cur * 2].data, a[cur * 2 + 1].data);
    }

    // 把一个Node的mark传递到其子节点
    private void spread(int cur) {
        if (a[cur].mark != 0) { // 曾经懒惰删除过
            if (a[cur * 2] != null) {
                a[cur * 2].data = Math.max(a[cur * 2].data, a[cur].mark); // 更新子节点数据
                a[cur * 2].mark = Math.max(a[cur * 2].mark, a[cur].mark); // 传递mark
            }
            if (a[cur * 2 + 1] != null) {
                a[cur * 2 + 1].data = Math.max(a[cur * 2 + 1].data, a[cur].mark);
                a[cur * 2 + 1].mark = Math.max(a[cur * 2 + 1].mark, a[cur].mark);
            }   
            a[cur].mark = 0; // 清空
        }
    }
}

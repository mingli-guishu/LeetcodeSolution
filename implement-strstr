class Solution {
  // 28 Easy 实现strStr() implement-strstr
  // Rabin-Karp模板
  public int strStr(String haystack, String needle) {
        String orign_neddle = needle;
        int haylen = haystack.length();
        int neelen = needle.length();
        final int p = (int)1e9 + 7; // 大质数
        haystack = " " + haystack;
        needle = " " + needle;
        // init
        long hash_needle = 0;
        for (int i = 1; i <= neelen; i++)
            hash_needle = (hash_needle * 131 + (needle.charAt(i) - 'a' + 1)) % p;
        long[] hash_hay = new long[haylen + 1];
        long[] p131 = new long[haylen + 1]; // 131 的指数
        hash_hay[0] = 0;
        p131[0] = 1;
        for (int i = 1; i <= haylen; i++) {
            p131[i] = p131[i - 1] * 131 % p;
            hash_hay[i] = (hash_hay[i - 1] * 131 + (haystack.charAt(i) - 'a' + 1)) % p;
        }

        for (int i = neelen; i <= haylen; i++)
            // 要和没有加空格的比较作为特判
            if (calhash(hash_hay, p131, p, i - neelen + 1, i) == hash_needle &&
                haystack.substring(i - neelen + 1, i + 1).equals(orign_neddle)) 
                return i - neelen; // 本应该返回 i - neelen + 1，但由于主动增长了两个字符串便减一
        return -1;
        
    }

    private long calhash(long[] hash, long[] p131, int p, int l, int r) {
        // return (hash[r] - hash[l] * p131[r - l + 1]) % p; 此时减法有可能出现负数
        return ((hash[r] - hash[l - 1] * p131[r - l + 1]) % p + p) % p; // + p再取模
    }
    
    // 简单解法
    public int strStr(String haystack, String needle) {
        int lenhay = haystack.length();
        int lenndl = needle.length();
        if(needle.equals("")) return 0;
        if(lenhay < lenndl) return -1;

        for(int i = 0; i < lenhay - lenndl + 1; i++){
            if(haystack.substring(i, i + lenndl).equals(needle))
                return i;
        }
        return -1;
    }
}

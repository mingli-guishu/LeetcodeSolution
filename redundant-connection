class Solution {
    // 684 Medium 冗余连接 redundant-connection
    // 全局解法
    List<List<Integer>> alledges;// 存储图数据
    boolean[] visit;// 是否已访问
    boolean hasCycle = false;
    int num = 0;// 节点总数
    public int[] findRedundantConnection(int[][] edges) {
        // 先得到有节点总数
        for (int i = 0; i < edges.length; i++)
            num = Math.max(num, Math.max(edges[i][0], edges[i][1]));
        visit = new boolean[num + 1];
        // 边的存储
        alledges = new ArrayList<List<Integer>>();
        for (int i = 0; i <= num; i++)
            alledges.add(new ArrayList<Integer>());
        // 每次添加一条无向边，然后check是否有环
        for (int i = 0; i < edges.length; i++) {
            int u = edges[i][0];
            int v = edges[i][1];
            // 无向图就是双向图
            alledges.get(u).add(v);
            alledges.get(v).add(u);
            // 每次开始前状态还原
            for (int j = 0; j <= num; j++)
                visit[j] = false;
            // 此时一定没有环，因为一旦有早就return了，所以从当前插入的边的一段开始搜索
            dfs(u, -1);
            if (hasCycle)
                return edges[i];
        }
        return new int[2];
    }

    // 深度优先搜索查看有没有环
    private void dfs(int cur, int farther) {
        // 终止条件
        if (hasCycle)
            return;
        visit[cur] = true;
        for (int next : alledges.get(cur)) {
            if (next == farther) // 防止原路返回
                continue;
            if (visit[cur]) {
                hasCycle = true;
                return;
            }
            dfs(next, cur);
        }
    }
    
    // 并查集解法
}
